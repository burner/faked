module fakerjsgenerator;

import std.algorithm;
import std.array;
import std.stdio;
import std.process;
import std.format;
import std.conv : to;
import std.exception : enforce;
import std.file : dirEntries, SpanMode, isDir, readText, isFile, exists,
       mkdirRecurse, read;
import std.algorithm;
import std.string;
import std.typecons : Nullable, nullable;
import std.regex;

import jssplitter;
import generator;
import iban;

enum outputDir = "../source/faked/";

void main() {
	cloneFaker();
	FakerData[] locales = scrapeFakers();
    mkdirRecurse(outputDir);

	auto list =
		[ "af_ZA", "de_CH", "en_CA", "en_US", "fr", "hr", "ja", "nl"
		, "ru", "vi", "ar", "el", "en_GB", "en_ZA", "fr_BE", "hu", "ko"
		, "nl_BE", "sk", "zh_CN", "az", "en_GH", "es", "fr_CA"
		, "hy", "lv", "pl", "sv", "zh_TW", "en_AU", "en_IE"
		, "es_MX", "fr_CH", "id_ID", "mk", "pt_BR", "tr", "zu_ZA", "de"
		, "en_AU_ocker", /*"en_IND",*/ "fa", /*"ge",*/ "pt_PT"
		, "uk", "de_AT", "en_BORK", "en_NG", "fi", "he", "it", "ne"
		, "ro", "ur"
		, "af_ZA", "de_AT", "en_AU_ocker", "en_IE", "es", "fr_BE", "hr", "it"
		, "nb_NO", "pt_BR", "sv", "zh_CN" , "ar", "de_CH", "en_BORK"/*, "en_IND"*/
		, "es_MX", "fr_CA", "hu", "ja", "ne", "pt_PT", "tr", "zh_TW", "az"
		, "el", "en_CA", "en_NG", "fa", "fr_CH", "hy", "ko", "nl", "ro", "uk"
		, "zu_ZA", /*"cz", "en",*/ "en_GB", "en_US", "fi", /*"ge",*/ "id_ID", "lv"
		, "nl_BE", "ru", "ur", "de", "en_AU", "en_GH", "en_ZA", "fr", "he"
		, "mk", "pl", "sk", "vi"
		].sort.uniq.array;


    auto en = locales.find!(a => a.locale == "en").front;
    string[] methods = buildFile("en", en, []);
    methods ~= ["addressLatitude", "addressLongitude", "financeAccount",
        "financeRoutingNumber", "financeMask", "financeBitcoinAddress",
        "phoneNumber", /*"commerceProductName",*/ "companyCatchPhrase",
        "companyBs", "internetUserName", "internetProtocol",
        "internetDomainWord", "internetDomainName", "internetUrl",
        "internetIPv4", "internetIPv6", "internetColor", "internetPassword",
        "vehicle", "vehicleVin", "helperAlpha", "helperAlphaNum",
        "helperHexaDecimal",
    ];
    methods = methods.sort.uniq.array;

    //writefln("%(%s\n%)", methods);
    foreach(ll; list) {
	    auto f = locales.find!(a => a.locale == ll);
        assert(!f.empty, ll);
        buildFile(ll, f.front, methods);
    }

    buildInstantionTest(list ~ "en", methods);

    writePackageFile(list);
}

void writePackageFile(string[] list) {
    auto f = File(outputDir ~ "package.d", "w");
    auto ltw = f.lockingTextWriter();

    formattedWrite(ltw, "// generated by fakerjsgenerator\n");
    formattedWrite(ltw, "module faked;\n\n");
    formattedWrite(ltw, "///\npublic import faked.base;\n\n");
    foreach(l; list) {
        formattedWrite(ltw, "///\npublic import faked.faker_%s;\n\n", toLower(l));
    }
}

void buildInstantionTest(string[] list, string[] methods) {
    auto f = File(outputDir ~ "test.d", "w");
    auto ltw = f.lockingTextWriter();
    formattedWrite(ltw, "// generated by fakerjsgenerator\n");
    formattedWrite(ltw, "module faked.test;\n\nimport std.array : empty;\n");
    formattedWrite(ltw, "import std.stdio;\n");
    formattedWrite(ltw, "import std.format : format;\n\n");

	formattedWrite(ltw, `
struct ToIgnore {
	string lang;
	string[] methods;
}

const allowedToFail =
	[ ToIgnore("az"
		, ["addressState", "companySuffix", "namePrefix", "nameSuffix"])
	, ToIgnore("cz" , ["addressState", "addressStateAbbr"])
	, ToIgnore("id_ID", ["namePrefix"])
	, ToIgnore("it", ["nameSuffix"])
	, ToIgnore("mk", ["nameSuffix"])
	, ToIgnore("pt_BR", ["addressCityPrefix"])
	, ToIgnore("pt_PT", ["addressCityPrefix", "addressCitySuffix", "nameSuffix"])
	, ToIgnore("ru", ["nameSuffix", "namePrefix"])
	, ToIgnore("sk", ["addressState", "addressStateAbbr"])
	];

void fakedAssert(D)(D fakeData, const string lang, const string method, const long round) {
	foreach(ref l; allowedToFail) {
		if(l.lang == lang) {
			foreach(m; l.methods) {
				if(m == method) {
					if(fakeData.empty) {
						//writefln("%%5s %%20s %%3d gives no data as expected", lang, method, round);
						return;
					} else {
						assert(false, format("%%5s %%20s %%3d was expected to give no data", lang, method, round));
					}
				}
			}
		}
	}
	assert(!fakeData.empty, format("%%5s %%20s %%3d failed to give data", lang
				, method, round));
}

`);

    string ut = `unittest {
%s;
    auto faker = new %s(%d);
%s}

`;
    foreach(idx, l; list) {
		string calls = "\tfor(int i = 0; i < 30; ++i) {\n" ~
    	    methods
    	        .map!(a => format(
					"\t\tfakedAssert(faker.%1$s(), \"%2$s\", \"%1$s\", i);\n", a, l))
    	        .joiner()
    	        .to!string()
    	    ~ "\n\t}\n";

        formattedWrite(ltw, ut,
            l == "en"
                ? "\timport faked.base"
                : "\timport faked.faker_" ~ toLower(l),
            l == "en" ? "Faker" : "Faker_" ~ toLower(l),
            idx + 1, calls
        );
    }
}

string[] buildFile(string ll, FakerData entry, string[] toOverride) {
	//writeln(f.front);
    string[] methods;
	Generator gen = new Generator(ll, entry.fallback, toOverride);
	foreach(string key, Entry value; entry.data) {
		if(ignoreEntries.canFind(key)) {
			continue;
		}
		foreach(string sub, Data svalue; value.subs) {
			Direct d = cast(Direct)svalue;
			if(d !is null) {
				if(ll == "ur" && key == "address" && sub == "city_name") {
					continue;
				}
				if(ll == "fa" && key == "finance" && sub == "credit_card") {
					continue;
				}

                if(key == "name" && sub == "title") {
                    methods ~= gen.buildNameTitle(d.data);
                    continue;
                }
                if(key == "finance" && sub == "currency") {
                    methods ~= gen.buildFinanceCurrency(d.data);
                    continue;
                }
                if(key == "commerce" && sub == "product_name") {
                    methods ~= gen.buildCommerceProductName(d.data);
                    continue;
                }
				if(key == "name" && d.data.canFind("concat")) {
					methods ~= gen.buildConcat(ll, key, sub, d.data);
					continue;
				}
				if(d.data.canFind("concat(")) {
					writefln("TODO %s %s %s TODO", ll, key, sub);
					continue;
				}
				//write(key, ".", sub, " ");
				//writefln("%s %s %s %s", __LINE__, ll, key, sub);
				Nullable!TypeLines tlN = jssplit(d.data, ll ~ " " ~ key ~ " " ~ sub);
				if(tlN.isNull()) {
					continue;
				}
				TypeLines tl = tlN.get();
				//writeln(tl.type);
				if(tl.type == Type.strings) {
					methods ~= gen.buildString(key, sub, tl.lines);
				} else if(tl.type == Type.digit) {
					methods ~= gen.buildDigits(key, sub, tl.lines);
				} else if(tl.type == Type.call) {
					methods ~= gen.buildCall(key, sub, tl.lines);
				} else {
					if(key == "address" && sub == "postcode_by_state") {
						writefln("IGNORED HERE %s %s %s %s", __FILE__, __LINE__
								, key, sub);
						continue;
					}
					if(tl.lines.empty) {
						writefln("No lines for %s %s %s", ll, key, sub);
					}
					methods ~= gen.buildMustache(ll, key, sub, tl.lines);
					//writefln("Not handled %s %s %s %s", ll, key, sub
					//		, tl.type);
				}
			} else {
                Sub s = cast(Sub)svalue;
                if(key == "finance" && sub == "credit_card" && s !is null) {
                    methods ~= gen.buildCreditCards(s);
                }
            }
		}
	}

    string fname = (ll == "en")
        ? "base.d"
        : "faker_" ~ toLower(ll) ~ ".d";

    if(ll == "en") {
        methods ~= gen.buildIbanAndBic();
        methods ~= ["addressLatitude", "addressLongitude", "financeAccount",
                "financeRoutingNumber", "financeMask", "financeBitcoinAddress",
                "loremSentance", "loremSentances", "loremParagraph",
                "loremParagraphs", "loremText", "phoneNumber"];
    }

	gen.finish();

	auto fout = File(outputDir ~ fname, "w");
    auto ltw = fout.lockingTextWriter();
    formattedWrite(ltw, "// generated by fakerjsgenerator\n");
	fout.write(gen.output);

    //return methods.filter!(a => !a.empty).array;
    return methods.sort.array;
}

const fakerFolder = "faker";

const string[] ignoreListLocals = [];
const string[] ignoreEntries = ["system"];

class Data {
	override string toString() const {
		assert(false);
	}
}

class Direct : Data {
	string data;

	this(string d) {
		this.data = d;
	}

	override string toString() const {
		return format("    Direct \n%s", this.data);
	}
}

class Sub : Data {
	string index;
	Direct[string] subs;

	override string toString() const {
		string ret;
		foreach(key, value; subs) {
			ret ~= format("\n            %s", key);
		}
		return ret;
	}
}

struct Entry {
	string index;
	Data[string] subs;

	void toString(scope void delegate(const(char)[]) sink) const {
		foreach(key, const(Data) value; this.subs) {
			formattedWrite(sink, "        %s:%s\n", key, value.toString());
		}
	}
}

class FakerData {
	string locale;
	string fallback;
	Entry[string] data;

	void toString(scope void delegate(const(char)[]) sink) const {
		formattedWrite(sink, "%s fallback %s\n", this.locale, fallback);
		foreach(key, value; this.data) {
			formattedWrite(sink, "    %s:\n", key);
			value.toString(sink);
		}
	}
}

void cloneFaker() {
	import std.file : exists, rmdirRecurse;

	if(exists(fakerFolder)) {
        return;
	}

	auto rslt = executeShell(
            "git clone --depth=1 https://github.com/faker-js/faker.git"
        );
	enforce(rslt.status == 0,
		format("Failed to clone faker.js with message %s %s", rslt.status,
			rslt.output)
	);
}

FakerData[] scrapeFakers() {
	FakerData[] ret;
	const fakerLocales = fakerFolder ~ "/src/locales/";

	outer: foreach(f; dirEntries(fakerLocales, SpanMode.shallow)) {
		foreach(ig; ignoreListLocals) {
			if(f.name.endsWith(ig)) {
				continue outer;
			}
		}
		if(isDir(f.name)) {
			ret ~= scrapeFaker(f.name);
			buildFallback(ret.back);
		}
	}
	return ret;
}

FakerData scrapeFaker(string foldername) {
	auto ret = new FakerData();
	string name = foldername[foldername.lastIndexOf("/") + 1 .. $];
	ret.locale = name;

	foreach(f; dirEntries(foldername, SpanMode.shallow)) {
		Entry entry;
		if(f.name.endsWith("index.ts")) {
			string iFile = "./" ~ f.name;
			assert(isFile(iFile));
			entry.index = readText(iFile);
			continue;
		}
		if(isDir(f.name)) {
			foreach(g; dirEntries(f, SpanMode.shallow)
					.filter!(a => !a.name.canFind("index.ts")))
			{
				if(isFile(g.name)) {
					string s = g.name;
					s = s[s.lastIndexOf("/") + 1 .. $ - 3];
					auto t = cast(string)read(g.name);
					entry.subs[s] = new Direct(t);
				} else {
					auto sub = new Sub();
					sub.index = readText(g.name ~ "/index.ts");
					foreach(h; dirEntries(g.name, SpanMode.shallow)
							.filter!(a => !a.name.canFind("index.ts")))
					{
						string sh = h.name;
						sh = sh[sh.lastIndexOf("/") + 1 .. $ - 3];

						if(isFile(h)) {
							sub.subs[sh] = new Direct(readText(h));
						}
					}
					entry.subs[g.name[g.name.lastIndexOf("/") + 1 .. $]] = sub;
				}
			}
		}
		ret.data[f.name[f.name.lastIndexOf("/") + 1 .. $]] = entry;
	}
	return ret;
}

enum r = r"\{\s*locale:\s*'([a-zA-Z_]\+)'\s*,\s*localeFallback\s*:'([a-zA-Z_]\+)'\s*\}";
enum r2 = r"'(\w*)'";
auto re = regex(r2);

void buildFallback(FakerData fd) {
	string t = fakerFolder ~ "/locale/" ~ fd.locale ~ ".ts";
	if(!exists(t)) {
		return;
	}

	string[] tt = readText(t).split("\n");
	foreach(l; tt) {
		enum pre = "var faker = new Faker(";
		if(l.startsWith(pre)) {
			string narrow = l[pre.length .. $ - 2];
			auto m = matchAll(narrow, re);
			if(!m.empty) {
				string f = m.front.hit.strip("'");
				assert(f == fd.locale,
					format("%s %s %s", fd.locale, f, t)
				);
				m.popFront();
				f = m.front.hit.strip("'");
				if(!m.empty) {
					fd.fallback = f;
				}
			}
		}
	}
}
